- App Service
  - http based service for hosting web apps
  - web hosting 
  - windows or linux
  - Egs of web apps: ASP.net, APS.net core, Node.js, Python, PHP etc.
- App service Plans
  - Isolated and Non-Isolated
  - Non-Isolated:
    - not inside a virtual network
    - can be accessed via internet
    - Types:
      - Non-prod
        - ***Free and shared(F1, D1)***: 
          - not for PROD apps
          - run on shared infrastructure
          - for development and testing 
          - metered on a per-app basis(cpu minutes)
          - not scalable
        - ***Basic(B1,B2,B3)***:
          - low traffic requirement apps, 
          - no autoscaling and no traffic management.
            - but manual scaling to multiple instances is possible 
          - not for PROD envs.
          - pricing based on size and no. of instances. 
          - provides load balancing between instances. 
          - supports container for linux runtimes.(Web App for Containers)
      - PROD(autoscaling provided - ***scaling up only***): scaling down needs manual scaling
        - ***Standard(S1,S2,S3)***: 
          - for PROD workloads 
          - price based on no. of instances run
          - autoscaling
        - ***Premium v2(P1v2, P2v2, P3v2)***:
          - enhanced performance
          - higher scaling
        - ***Premium v3(P1v3, P2v3, P3v3)***:
          - faster processor
          - p1v3: max 30 instances in autoscaling
        - ***Isolated tier*** with ***App Service Environments(ASE)***:
          - fully isolated and dedicated environment for running web apps
          - environment is dedicated to your app and able to put in VNet.
          - high scale, memory utilization
          - secure network access
          - control over network traffic
          - app can connect to VPN to on-premise resources
          - allows up to 100 instances in autoscaling 
- Create Azure Service Web Apps
  - App service plans
  - App service environments
  - create web app in portal
  - create web app with CLI
  - create web app with powershell
  - create web app with ARM template
- Steps to create a web app:
  - Go to App Service in azure portal
  - or search for web app

- Configuring Azure App Service
  - Securing web app with SSL
    - Secure a domain with SSl/TLS Binding
      - Use Basic, Standard, Premium or Isolated plan(Free plan doesn't provide SSL)
      - Public(Commercial certificate from authority like VeriSign) - Commonly used vs Private certificates(self generated)
      - Managed(purchase certificate from Azure and map to our domain called app service certificate) vs un-managed certificates(Own self-signed certificates, commercial vendor)
      - enforce HTTPS and TLS(Transport Layer Security)
  - Process to map a custom domain to app service
    - Go to Create a resource in portal
    - Go to web app -> Custom domains -> Add custom domain, copy domain verification details and hostname
    - Search for ***App Service Domain*** -> Create domain and add cname record to verify that you own the domain with alias as hostname(.azurewebsites.net)
    - Add record set type:txt, name:asuid.www, paste domain verification ID in value.
    - For TLS/SSL: Go to web app-> TLS/SSL settings -> upload certificates or create a new one.
  - Configuring a DB Connection String
    - so that we don't have to hardcode into code when trying to connect to db
    - instead we can directly use the connection string present in memory as a variable
    - Steps:
      - Create a sql database in same location and resource group as webapp
      - Open db and copy connection string
      - Go to webapp -> configuration -> Connection String -> new -> update password inside connection string
      - Connection strings can be kept in secure key vaults as well
- Enable Diagnostic Logging
  - For windows: 
    - Go to App Services -> select your webapp -> App Service logs
  - For Linux:
    - ?
    - Types:
      - ***Application Logging***: log messages generated by webapp - levels: warnings, critical, errors etc.
        - can be stored on file system where app/code is running
        - or azure storage
      - ***Web server logging***: can be stored on App Service file system where app/code is running or Azure Storage
        - log raw HTTP requests that comes in: 
          - HTTP request made
          - method used
          - client IP etc.
      - ***Detailed Error Messages***
        - For windows based app service
        - users can't see these errors but useful for developers
      - ***Failed request tracing***
        - For windows based app service
        - Detailed information on failed requests
        - Includes Trace of IS components used to process the requests and time it takes in each component to finish that process. *?
      - ***Deployment logging***
        - both linux and windows based app services
        - logs when code is pushed to app service
        - deployment time error handling.
- Deploying code to app service web app
  - Configuring continuous deployment
    - pulls code from 
      - GitHub, 
      - Bitbucket, 
      - FTP: Azure Repos(part of Azure DevOps) 
      - local Git 
      - and updates the deployment
  - Configuring continuous delivery
    - Azure DevOps or some other CI/CD system
  - Steps:
    - Authorize Azure App Service
      - go to web app -> Deployment center -> 
      - Define source control: Git, Azure Repos, Bitbucket, Local Git repo, manual deployment(push/sync): onedrive, dropbox, external, FTP
      - build provider: .Net compiler 
        - App service build service: kudu engine
        - GitHub actions
        - Azure pipelines
      - configure
    - Enable Continuous Deployment
    - Disable Continuous Deployment
- Scaling Azure App Service
  - Autoscale:
    - adjust resources based on current demand 
    - available for standard, premium,and isolated tiers only.
    - Vertical vs Horizontal scaling
      - Vertical: adding resources: scale up vs down
      - Horizontal: adding extra VMs using load balancers - Scaling In(reducing VM count) vs OUT(adding more VM)
  - Manually scaling App Service
    - Scale up and scale out option in portal
  - Scaling on a schedule: based on time. scale out at 9 am, scale back in at 10pm
    - scale out -> custom autoscale
  - Implementing autoscaling in app service
    - Autoscaling profile
      - Azure Autoscaling actions: monitor resources of web app and detect requirements for additional resources
        - inc/dec no. of VMs.
        - send email notification of scaling change
        - ping a webhook as a notification to start some automated process
      - Capacity settings: max, min and default no. of instances
      - Rules: based on conditions
      - Notifications: via Azure Monitor
    - Designing Autoscaling Rules
      - Metrics(resource/custom): CPU utilization, compute instances, memory pressure, etc.
      - Time(schedule): 
  - Configure application settings for web app
    - portal -> app service -> Settings -> Configuration -> app settings, connection strings
    - DONOT store keys here, store keys in azure key vault and use the reference here.
  - Configure application settings using code
    - add and edit settings in bulk using format to set connection strings: [settings.json](settings.json)
- Deploy to App Service
  - Automated deployment
    - Azure DevOps
    - GitHub
    - Bitbucket
  - Manual deployment
    - Git
    - CLI
    - Zipdeploy
    - FTP/S
  - using deployment slots
    - for testing PROD builds
- Configure settings in App Service:
  - Stack settings
    - software stack to run the app
    - language
    - SDK version
  - Platform settings
    - bit(32 or 64-bit)
    - WebSocket protocol
    - Always On
    - Managed pipeline version
    - HTTP version
    - ARR affinity
  - Debugging
    - enable remote debugging for ASP.NET, ASP.NET Core or Node.js apps
  - Incoming client certificates
    - require client certificates in mutual authentication.
    - TLS mutual authentication is used to restrict access to your app by enabling different types of authentication for it.
- Options for configuring SSL
  - Buy and import App Service Certificate
  - Import certificate from Key Vault
  - Upload a private/public certificate
  - Renew an expiring/uploaded/App service cert
  - Renew a cert imported from Key Vault
  - Manage App Service certificates
  - Automate with scripts
- autoscaling: Benefits and demerits
  - Elasticity
  - Availability
  - Fault Tolerance
  - Add or remove web servers
  - not best for handling long-term growth
  - no. of instances is a factor
- Autoscaling best practices
  - Ensure max and min values are different and have adequate margin b/w them
    - to prevent flapping
      - where service continues to scale in and out rapidly
  - choose appropriate statistic for diagnostic metric
  - choose thresholds carefully for all metric types
  - remember considerations for scaling when multiple rules are configured in a profile
  - always select a safe default instance count
  - configure autoscale notifications
